package catz

import java.util.concurrent.Executors

import cats.data.Validated
import cats.{Applicative, ApplicativeError, Monad, MonadError}

import scala.concurrent.{ExecutionContext, Future}
import scala.util.Try
/*



 */
object HandlingErrortypeClass {

//TODO : this type class takes two arguments M[_] which is higher-kinded type
  // and another one is Error type E
  // type class instance of this type class will be generated by compiler if
  // we have type class instance of Monad in scope with this enhanced capability of raiseerror
  MonadError
  trait MyMonadError[M[_],E] extends Monad[M]{
    // this type class has fundamental method raiseError
    def raiseError[A] (e:E):M[A]
  }
  /*
    implicit def catsStdInstancesForEither[A]: MonadError[Either[A, *], A] with Traverse[Either[A, *]] =
    new MonadError[Either[A, *], A] with Traverse[Either[A, *]] {

     def raiseError[B](e: A): Either[A, B] = Left(e)
      def pure[B](b: B): Either[A, B] = Right(b)

      def handleErrorWith[B](fea: Either[A, B])(f: A => Either[A, B]): Either[A, B] =
        fea match {
          case Left(e)      => f(e)
          case r @ Right(_) => r
        }

   */
  import cats.implicits.catsStdInstancesForEither
  type ErrorOr[A] = Either[String,A]
  val typeClassinstanceMonadError: MonadError[ErrorOr, String] =
    MonadError.apply[ErrorOr,String]
// Lets test monad error type class
  val success: ErrorOr[Int] = typeClassinstanceMonadError.pure(2)
  val failure: ErrorOr[Int] = typeClassinstanceMonadError.
                        raiseError[Int]("Exception-Occurred!!!!")
  // TODO: tro recover from error type class gives additional method called handleError
 val handledError: ErrorOr[Int] = typeClassinstanceMonadError.
                handleError(failure){
                  case "badness" => 44
                  case _ => 89
                }

  val handleErrorWith: ErrorOr[Int] = typeClassinstanceMonadError
    .handleErrorWith(failure){
      case "badness" => typeClassinstanceMonadError.pure(44)
      case _ => Left("Inavlid Result")
    }
  //filter Turns a successful value into an error if it does not satisfy a given predicate.
  val filteredSuccess: ErrorOr[Int] = typeClassinstanceMonadError
    .ensure(success)("Number-too-Small-error")(_>100)

  //Todo MonadError type class instances for Try
  import cats.instances.try_._//implicit MonadError[Try,E] where E= throwable
  val exception= new RuntimeException("Really bad ")
  val MonaderrortypeclassinstanceforTry: MonadError[Try, Throwable] =
    MonadError[Try,Throwable]
  /*
  type class instance
   def handleErrorWith[A](ta: Try[A])(f: Throwable => Try[A]): Try[A] =
        ta.recoverWith { case t => f(t) }

      def raiseError[A](e: Throwable): Try[A] = Failure(e)


   */
  // val exception= new RuntimeException("Really bad ")
  val pureException: Try[Nothing] = MonaderrortypeclassinstanceforTry.raiseError(exception) // Failure

  //TODO : Monad Error Type class instance for Future

  implicit val ec: ExecutionContext = ExecutionContext.
    fromExecutorService(Executors.newFixedThreadPool(2))
  import cats.instances.future._
  /*
  Creates an already completed Future with the specified exception.
Returns:
the newly created Future instance
  def raiseError[A](e: Throwable): Future[A] = Future.failed(e)

Returns:
the newly created Promise object
  def failed[T](exception: Throwable): Future[T] = Promise.failed(exception).future


  def failed[T](exception: Throwable): Promise[T] = fromTry(Failure(exception))
   */
  val monadErrortypeclassInstanceForFuture: MonadError[Future, Throwable] =
    MonadError[Future,Throwable]

   val futureOfException: Future[Nothing] = monadErrortypeclassInstanceForFuture.
     raiseError(exception)

//TODO Monad Error Type class instance for Validated

  import cats.instances.list._//implicit Semigroup[List] because validated required semigroup
  //import cats.implicits.catsKernelStdMonoidForList
  /*
  An Applicative that also allows you to raise and or handle an error value.
 *
 * This type class allows one to abstract over error-handling applicatives.
   */
  /*
  TODO type class instance
     implicit def catsDataApplicativeErrorForValidated[E](implicit E: Semigroup[E]): ApplicativeError[Validated[E, *], E] =
    new ValidatedApplicative[E] with ApplicativeError[Validated[E, *], E] {

      def handleErrorWith[A](fa: Validated[E, A])(f: E => Validated[E, A]): Validated[E, A] =
        fa match {
          case Validated.Invalid(e)   => f(e)
          case v @ Validated.Valid(_) => v
        }
      def raiseError[A](e: E): Validated[E, A] = Validated.Invalid(e)
    }
   */
  type ErrorsOR[T] = Validated[List[String],T]
  val applicativeErrorTypeclass: ApplicativeError[ErrorsOR, List[String]] =
    ApplicativeError.apply[ErrorsOR, List[String]]

    /*
   TODO
     Actually the diffrence between ApplicativeError and MonadError is that raiseError is fundamental method of
     Applicative error not the monad error
   */

    trait MyApplicativeError[M[_], E] extends Applicative[M] {
      // this type class has fundamental method raiseError
      def raiseError[A](e: E): M[A]

      //second fundametal method of ApplicativeError is
      def handleErrorWith[A](fa: M[A])(f: E => M[A]): M[A]

      // third fundametal method of   ApplicativeError is
      def handleError[A](fa: M[A])(f: E => A): M[A] = handleErrorWith(fa)(e => pure(f(e)))

      // and at last the pure method from Applicative but this is auxiallary method
      def pure[A](x: A): M[A]
    }

    trait MyMonadError1[M[_], E] extends Monad[M] {
      // this type class has fundamental method raiseError
      def ensure[A](fa: M[A])(error: E)(predicate: A => Boolean): M[A]
    }
    // TODO : Extension methods for ApplicativeError and MonadError
    import cats.syntax.applicative._ // pure is here
    /*
      TODO
          implicit class ApplicativeIdOps[A](private val a: A) extends AnyVal {
          def pure[F[_]](implicit F: Applicative[F]): F[A] = F.pure(a)
              }
              i.e it will call Validated pure  def pure[A](a: A): Validated[E, A] = Validated.valid(a)
     */
    //import cats.syntax.applicativeError._// will import raiseError ,handleError , handleErrorWith
  //type ErrorsOR[T] = Validated[List[String],T]
    val extendedSuccess: ErrorsOR[Int] = 42.pure[ErrorsOR]


  def main(args: Array[String]): Unit = {

  }

}
